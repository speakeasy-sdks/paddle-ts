/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { z } from "zod";

export type Errors = {
    field: string;
    message: string;
};

export type Extra = {};

/**
 * If the subscription is locked and can not be changed. This happens 30 min before the renewal time.
 */
export type ErrorTData = {
    code: string;
    detail: string;
    documentationUrl: string;
    errors?: Array<Errors> | undefined;
    extra?: Extra | undefined;
    type: string;
};

/**
 * If the subscription is locked and can not be changed. This happens 30 min before the renewal time.
 */
export class ErrorT extends Error {
    code: string;
    detail: string;
    documentationUrl: string;
    errors?: Array<Errors> | undefined;
    extra?: Extra | undefined;
    type: string;

    /** The original data that was passed to this error instance. */
    data$: ErrorTData;

    constructor(err: ErrorTData) {
        super("");
        this.data$ = err;

        this.code = err.code;
        this.detail = err.detail;
        this.documentationUrl = err.documentationUrl;
        if (err.errors != null) {
            this.errors = err.errors;
        }
        if (err.extra != null) {
            this.extra = err.extra;
        }
        this.type = err.type;

        const msg = "message" in err && typeof err.message === "string" ? err.message : "";
        const content = JSON.stringify(err);
        this.message = [msg, content].filter(Boolean).join("\n");

        this.name = "ErrorT";
    }
}

/** @internal */
export namespace Errors$ {
    export type Inbound = {
        field: string;
        message: string;
    };

    export const inboundSchema: z.ZodType<Errors, z.ZodTypeDef, Inbound> = z
        .object({
            field: z.string(),
            message: z.string(),
        })
        .transform((v) => {
            return {
                field: v.field,
                message: v.message,
            };
        });

    export type Outbound = {
        field: string;
        message: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Errors> = z
        .object({
            field: z.string(),
            message: z.string(),
        })
        .transform((v) => {
            return {
                field: v.field,
                message: v.message,
            };
        });
}

/** @internal */
export namespace Extra$ {
    export type Inbound = {};

    export const inboundSchema: z.ZodType<Extra, z.ZodTypeDef, Inbound> = z.object({});

    export type Outbound = {};

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Extra> = z.object({});
}

/** @internal */
export namespace ErrorT$ {
    export type Inbound = {
        code: string;
        detail: string;
        documentation_url: string;
        errors?: Array<Errors$.Inbound> | undefined;
        extra?: Extra$.Inbound | undefined;
        type: string;
    };

    export const inboundSchema: z.ZodType<ErrorT, z.ZodTypeDef, Inbound> = z
        .object({
            code: z.string(),
            detail: z.string(),
            documentation_url: z.string(),
            errors: z.array(z.lazy(() => Errors$.inboundSchema)).optional(),
            extra: z.lazy(() => Extra$.inboundSchema).optional(),
            type: z.string(),
        })
        .transform((v) => {
            return new ErrorT({
                code: v.code,
                detail: v.detail,
                documentationUrl: v.documentation_url,
                ...(v.errors === undefined ? null : { errors: v.errors }),
                ...(v.extra === undefined ? null : { extra: v.extra }),
                type: v.type,
            });
        });
    export type Outbound = {
        code: string;
        detail: string;
        documentation_url: string;
        errors?: Array<Errors$.Outbound> | undefined;
        extra?: Extra$.Outbound | undefined;
        type: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ErrorT> = z
        .instanceof(ErrorT)
        .transform((v) => v.data$)
        .pipe(
            z
                .object({
                    code: z.string(),
                    detail: z.string(),
                    documentationUrl: z.string(),
                    errors: z.array(z.lazy(() => Errors$.outboundSchema)).optional(),
                    extra: z.lazy(() => Extra$.outboundSchema).optional(),
                    type: z.string(),
                })
                .transform((v) => {
                    return {
                        code: v.code,
                        detail: v.detail,
                        documentation_url: v.documentationUrl,
                        ...(v.errors === undefined ? null : { errors: v.errors }),
                        ...(v.extra === undefined ? null : { extra: v.extra }),
                        type: v.type,
                    };
                })
        );
}
