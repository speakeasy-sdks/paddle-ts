/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import { AdjustmentItemTotals } from "./adjustmentitemtotals";
import { AdjustmentPayoutTotals } from "./adjustmentpayouttotals";
import { AdjustmentTotals } from "./adjustmenttotals";
import { CurrencyCode2 } from "./currencycode2";
import { Schemasaction } from "./schemasaction";
import { SchemasstatusAdjustment } from "./schemasstatusadjustment";
import { TransactionItemProration } from "./transactionitemproration";
import { Expose, Transform, Type } from "class-transformer";

/**
 * Type of adjustment for this transaction item. `tax` and `proration` are automatically created by Paddle.
 *
 * @remarks
 * Include `amount` when creating a `partial` adjustment.
 */
export enum Adjustment2AdjustmentItemType {
    Full = "full",
    Partial = "partial",
    Tax = "tax",
    Proration = "proration",
}

export class Adjustment2AdjustmentItem extends SpeakeasyBase {
    /**
     * Amount adjusted before tax for this transaction item. Required when adjustment type is `partial`.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "amount" })
    amount?: string;

    /**
     * Unique Paddle ID for this adjustment item, prefixed with `adjitm_`.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "id" })
    id?: string;

    /**
     * Unique Paddle ID for this transaction item, prefixed with `txnitm_`.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "item_id" })
    itemId: string;

    /**
     * How proration was calculated for this item. Populated when a transaction is created from a subscription change, where `proration_billing_mode` was `prorated_immediately` or `prorated_next_billing_period`. Set automatically by Paddle.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "proration" })
    @Type(() => TransactionItemProration)
    proration?: TransactionItemProration;

    /**
     * Breakdown of the total for an adjustment item.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "totals" })
    @Type(() => AdjustmentItemTotals)
    totals?: AdjustmentItemTotals;

    /**
     * Type of adjustment for this transaction item. `tax` and `proration` are automatically created by Paddle.
     *
     * @remarks
     * Include `amount` when creating a `partial` adjustment.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "type" })
    type: Adjustment2AdjustmentItemType;
}

/**
 * Represents an adjustment entity.
 */
export class Adjustment2 extends SpeakeasyBase {
    /**
     * How this adjustment impacts the related transaction. `refund` adjustments must be approved by Paddle, and are created with the status `pending_approval`. `chargeback` and `chargeback_warning` adjustments are created automatically by Paddle.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "action" })
    action?: Schemasaction;

    /**
     * RFC 3339 datetime string of when this entity was created. Set automatically by Paddle.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "created_at" })
    @Transform(({ value }) => new Date(value), { toClassOnly: true })
    createdAt?: Date;

    /**
     * Whether this adjustment was applied to the related customer's credit balance. Only returned for `credit` adjustments.
     *
     * @remarks
     *
     * `false` when the related transaction `collection_mode` is `manual` and its `status` is `billed`. The adjustment is used
     * to reduce the `balance` due on the the transaction.
     *
     * `true` for automatically-collected transactions and `completed`
     * manually-collected transactions.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "credit_applied_to_balance" })
    creditAppliedToBalance?: boolean;

    /**
     * Supported three-letter ISO 4217 currency code.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "currency_code" })
    currencyCode?: CurrencyCode2;

    /**
     * Unique Paddle ID for this customer entity, prefixed with `ctm_`.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "customer_id" })
    customerId?: string;

    /**
     * Unique Paddle ID for this adjustment entity, prefixed with `adj_`.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "id" })
    id?: string;

    /**
     * List of items on this adjustment.
     */
    @SpeakeasyMetadata({ elemType: Adjustment2AdjustmentItem })
    @Expose({ name: "items" })
    @Type(() => Adjustment2AdjustmentItem)
    items?: Adjustment2AdjustmentItem[];

    /**
     * Breakdown of how this adjustment affects your payout balance.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "payout_totals" })
    @Type(() => AdjustmentPayoutTotals)
    payoutTotals?: AdjustmentPayoutTotals;

    /**
     * Why this adjustment was created. Appears in the Paddle Dashboard. Retained for record-keeping purposes.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "reason" })
    reason?: string;

    /**
     * Status of this adjustment. Set automatically by Paddle.
     *
     * @remarks
     *
     * `refund` adjustments must be approved by Paddle, and are created with the status `pending_approval`
     * until they move to `approved` or `rejected` on review.  `credit` adjustments are created with the status `approved`.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "status" })
    status?: SchemasstatusAdjustment;

    /**
     * Unique Paddle ID for this subscription entity, prefixed with `sub_`.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "subscription_id" })
    subscriptionId?: string;

    /**
     * Breakdown of the total for an adjustment.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "totals" })
    @Type(() => AdjustmentTotals)
    totals?: AdjustmentTotals;

    /**
     * Unique Paddle ID for this transaction entity, prefixed with `txn_`.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "transaction_id" })
    transactionId?: string;

    /**
     * RFC 3339 datetime string of when this entity was updated. Set automatically by Paddle.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "updated_at" })
    @Transform(({ value }) => new Date(value), { toClassOnly: true })
    updatedAt?: Date;
}
