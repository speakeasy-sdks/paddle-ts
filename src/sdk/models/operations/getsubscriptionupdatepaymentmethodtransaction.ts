/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import * as shared from "../shared";
import { AxiosResponse } from "axios";
import { Expose, Type } from "class-transformer";

export class GetSubscriptionUpdatePaymentMethodTransactionRequest extends SpeakeasyBase {
    /**
     * Paddle ID of the subscription entity to work with.
     */
    @SpeakeasyMetadata({ data: "pathParam, style=simple;explode=false;name=subscription_id" })
    subscriptionId: string;
}

export class GetSubscriptionUpdatePaymentMethodTransaction200ApplicationJSONTransactionCheckout extends SpeakeasyBase {
    /**
     * The URL built in order to execute a payment via a checkout. This can be `null` as we do have scenarios where a transaction can only be paid with a wire transfer or perhaps just not desired. When `collection_mode` is `automatic`, this URL will always be present. <br /><br /> It is built using the sellers approved domain along with the transaction ID param appended `?_ptxn={id}`
     */
    @SpeakeasyMetadata()
    @Expose({ name: "url" })
    url?: string;
}

/**
 * The status of the transaction itself. This field can be updated via a `PATCH` but you can only set a transaction to be `billed` or `canceled` manually. All other statuses are automatic.
 */
export enum GetSubscriptionUpdatePaymentMethodTransaction200ApplicationJSONTransactionStatus {
    Draft = "draft",
    Ready = "ready",
    Billed = "billed",
    Completed = "completed",
    Canceled = "canceled",
    PastDue = "past_due",
}

export class GetSubscriptionUpdatePaymentMethodTransaction200ApplicationJSONTransactionOutput extends SpeakeasyBase {
    /**
     * Represents an address entity.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "address" })
    @Type(() => shared.Address)
    address?: shared.Address;

    /**
     * ID of the Billing Address that this Transaction is for
     */
    @SpeakeasyMetadata()
    @Expose({ name: "address_id" })
    addressId?: string;

    /**
     * Only returned if adjustments exist for this transaction.
     */
    @SpeakeasyMetadata({ elemType: shared.Adjustment2 })
    @Expose({ name: "adjustments" })
    @Type(() => shared.Adjustment2)
    adjustments?: shared.Adjustment2[];

    @SpeakeasyMetadata()
    @Expose({ name: "billed_at" })
    billedAt?: string;

    @SpeakeasyMetadata()
    @Expose({ name: "billing_details" })
    @Type(() => shared.BillingDetails1)
    billingDetails?: shared.BillingDetails1;

    /**
     * The period of time that this transaction covers. This is used by recurring subscription transactions as well as all invoicing transactions to indicate the period of time the charges in the transaction relate to
     */
    @SpeakeasyMetadata()
    @Expose({ name: "billing_period" })
    @Type(() => shared.TransactionBillingPeriod)
    billingPeriod?: shared.TransactionBillingPeriod;

    /**
     * Represents a business entity.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "business" })
    @Type(() => shared.Business)
    business?: shared.Business;

    /**
     * ID of the Business that this Transaction is for
     */
    @SpeakeasyMetadata()
    @Expose({ name: "business_id" })
    businessId?: string;

    @SpeakeasyMetadata()
    @Expose({ name: "checkout" })
    @Type(() => GetSubscriptionUpdatePaymentMethodTransaction200ApplicationJSONTransactionCheckout)
    checkout?: GetSubscriptionUpdatePaymentMethodTransaction200ApplicationJSONTransactionCheckout;

    /**
     * Describes how the payment is collected. Manual mode is for invoicing where a customer is first sent an invoice and requires manual intervention on their end to initiate a payment and there are normally payment terms involved eg they have to pay within 30 days. Automatic payments are where there is not usually any action on the sellers part to initiate a payment eg a customer visits a website and purchases something via a checkout or when a recurring transaction for a subscription is paid for via a payment method that is stored on file.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "collection_mode" })
    collectionMode?: shared.CollectionMode1;

    /**
     * Timestamp following the RFC 3339 standard
     */
    @SpeakeasyMetadata()
    @Expose({ name: "created_at" })
    createdAt?: string;

    /**
     * ISO 4217 code of a currency
     */
    @SpeakeasyMetadata()
    @Expose({ name: "currency_code" })
    currencyCode?: shared.CurrencyCode1;

    /**
     * Your own structured key-value data.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "custom_data" })
    @Type(() => shared.CustomData)
    customData?: shared.CustomData;

    /**
     * Represents a customer entity.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "customer" })
    @Type(() => shared.Customer)
    customer?: shared.Customer;

    /**
     * ID of the Customer that this Transaction is for
     */
    @SpeakeasyMetadata()
    @Expose({ name: "customer_id" })
    customerId?: string;

    /**
     * Calculated totals for a transaction, including proration, discounts, tax, and currency conversion. Considered the source of truth for totals on a transaction.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "details" })
    @Type(() => shared.TransactionDetails)
    details?: shared.TransactionDetails;

    /**
     * Represents a discount entity.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "discount" })
    @Type(() => shared.Discount)
    discount?: shared.Discount;

    /**
     * ID of the discount you want to apply
     */
    @SpeakeasyMetadata()
    @Expose({ name: "discount_id" })
    discountId?: string;

    /**
     * A short prefixed ID format by Paddle.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "id" })
    id?: string;

    /**
     * ID of the Invoice associated to this transaction
     */
    @SpeakeasyMetadata()
    @Expose({ name: "invoice_id" })
    invoiceId?: string;

    /**
     * A unique invoice reference, that is sequential and gapless
     */
    @SpeakeasyMetadata()
    @Expose({ name: "invoice_number" })
    invoiceNumber?: string;

    @SpeakeasyMetadata({ elemType: shared.TransactionItem })
    @Expose({ name: "items" })
    @Type(() => shared.TransactionItem)
    items: shared.TransactionItem[];

    /**
     * Indicates what initiated this transaction. Read only for sellers - read/write for Paddle
     */
    @SpeakeasyMetadata()
    @Expose({ name: "origin" })
    origin?: shared.TransactionOrigin;

    /**
     * An array of payment attempts sorted by `created_at` in descending order
     */
    @SpeakeasyMetadata({ elemType: shared.TransactionPaymentAttempt })
    @Expose({ name: "payments" })
    @Type(() => shared.TransactionPaymentAttempt)
    payments?: shared.TransactionPaymentAttempt[];

    /**
     * The status of the transaction itself. This field can be updated via a `PATCH` but you can only set a transaction to be `billed` or `canceled` manually. All other statuses are automatic.
     */
    @SpeakeasyMetadata()
    @Expose({ name: "status" })
    status?: GetSubscriptionUpdatePaymentMethodTransaction200ApplicationJSONTransactionStatus;

    /**
     * ID of the Subscription that this transaction belongs to
     */
    @SpeakeasyMetadata()
    @Expose({ name: "subscription_id" })
    subscriptionId?: string;

    /**
     * Timestamp following the RFC 3339 standard
     */
    @SpeakeasyMetadata()
    @Expose({ name: "updated_at" })
    updatedAt?: string;
}

/**
 * OK
 */
export class GetSubscriptionUpdatePaymentMethodTransaction200ApplicationJSONOutput extends SpeakeasyBase {
    @SpeakeasyMetadata()
    @Expose({ name: "data" })
    @Type(() => GetSubscriptionUpdatePaymentMethodTransaction200ApplicationJSONTransactionOutput)
    data?: GetSubscriptionUpdatePaymentMethodTransaction200ApplicationJSONTransactionOutput;
}

export class GetSubscriptionUpdatePaymentMethodTransactionResponse extends SpeakeasyBase {
    /**
     * HTTP response content type for this operation
     */
    @SpeakeasyMetadata()
    contentType: string;

    @SpeakeasyMetadata()
    headers?: Record<string, string[]>;

    /**
     * HTTP response status code for this operation
     */
    @SpeakeasyMetadata()
    statusCode: number;

    /**
     * Raw HTTP response; suitable for custom response parsing
     */
    @SpeakeasyMetadata()
    rawResponse?: AxiosResponse;

    /**
     * OK
     */
    @SpeakeasyMetadata()
    getSubscriptionUpdatePaymentMethodTransaction200ApplicationJSONObject?: GetSubscriptionUpdatePaymentMethodTransaction200ApplicationJSONOutput;
}
