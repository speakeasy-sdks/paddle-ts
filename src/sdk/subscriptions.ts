/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config";
import * as enc$ from "../lib/encodings";
import { HTTPClient } from "../lib/http";
import { ClientSDK, RequestOptions } from "../lib/sdks";
import * as errors from "../sdk/models/errors";
import * as operations from "../sdk/models/operations";

export class Subscriptions extends ClientSDK {
    private readonly options$: SDKOptions;

    constructor(options: SDKOptions = {}) {
        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
        });

        this.options$ = options;
        void this.options$;
    }
    /**
     * Cancel a subscription
     *
     * @remarks
     * Cancels a subscription using its ID.
     *
     * For active subscriptions, cancellation takes place at the end of a subscription billing period. If successful, your response includes a copy of the updated subscription entity with a `schedule_change` to say that the subscription should cancel at the end of the billing period. Its `status` remains the same until after the effective date of the scheduled change, at which point it changes to `canceled`.
     *
     * For paused subscriptions, cancellation takes place immediately. If successful, your response includes a copy of the updated subscription entity with the `status` of `canceled`.
     *
     * You cannot reactivate a canceled subscription.
     */
    async cancel(
        input: operations.CancelSubscriptionRequest,
        options?: RequestOptions
    ): Promise<operations.CancelSubscriptionResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = operations.CancelSubscriptionRequest$.outboundSchema.parse(input);

        const body$ = enc$.encodeJSON("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            subscription_id: enc$.encodeSimple("subscription_id", payload$.subscription_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/subscriptions/{subscription_id}/cancel")(
            pathParams$
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.CancelSubscriptionResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.CancelSubscriptionResponseBody$.inboundSchema.parse({
                ...responseFields$,
                Headers: this.unpackHeaders(response.headers),
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = errors.CancelSubscriptionSubscriptionsResponseBody$.inboundSchema.parse({
                ...responseFields$,
                Headers: this.unpackHeaders(response.headers),
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 409, "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorT$.inboundSchema.parse({
                ...responseFields$,
                Headers: this.unpackHeaders(response.headers),
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 500, "application/json")) {
            const responseBody = await response.json();
            const result =
                errors.CancelSubscriptionSubscriptionsResponseResponseBody$.inboundSchema.parse({
                    ...responseFields$,
                    Headers: this.unpackHeaders(response.headers),
                    ...responseBody,
                });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Create a one-time charge for a subscription
     *
     * @remarks
     * Creates a new one-time charge for a subscription. Use to bill non-recurring items to a subscription. Non-recurring items are price entities where the `billing_cycle` is `null`.
     *
     * If successful, Paddle responds with the updated subscription entity. However, one-time charges aren't held against the subscription entity, so the charges billed aren't returned in the response.
     *
     * Once created, to get details of a one-time charge:
     *
     * * When created with `effective_from` as `next_billing_period`, get the subscription the charge was billed to and use the `include` query parameter with the `next_transaction` value.
     * * When created with `effective_from` as `immediately`, list transactions and use the `subscription_id` query parameter with the subscription ID of the subscription the charge was billed to.
     */
    async create(
        input: operations.CreateSubscriptionChargeRequest,
        options?: RequestOptions
    ): Promise<operations.CreateSubscriptionChargeResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = operations.CreateSubscriptionChargeRequest$.outboundSchema.parse(input);

        const body$ = enc$.encodeJSON("body", payload$["subscription-charge"], { explode: true });

        const pathParams$ = {
            subscription_id: enc$.encodeSimple("subscription_id", payload$.subscription_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/subscriptions/{subscription_id}/charge")(
            pathParams$
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 201, "application/json")) {
            const responseBody = await response.json();
            const result = operations.CreateSubscriptionChargeResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.CreateSubscriptionChargeResponseBody$.inboundSchema.parse({
                ...responseFields$,
                Headers: this.unpackHeaders(response.headers),
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 500, "application/json")) {
            const responseBody = await response.json();
            const result =
                errors.CreateSubscriptionChargeSubscriptionsResponseBody$.inboundSchema.parse({
                    ...responseFields$,
                    Headers: this.unpackHeaders(response.headers),
                    ...responseBody,
                });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Preview one-off charge for a subscription
     *
     * @remarks
     * Previews a new one-off charge for a subscription. Use to preview the outcome of adding non-recurring items to a subscription.
     */
    async createPreview(
        input: operations.CreateSubscriptionChargePreviewRequest,
        options?: RequestOptions
    ): Promise<operations.CreateSubscriptionChargePreviewResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ =
            operations.CreateSubscriptionChargePreviewRequest$.outboundSchema.parse(input);

        const body$ = enc$.encodeJSON("body", payload$["subscription-charge"], { explode: true });

        const pathParams$ = {
            subscription_id: enc$.encodeSimple("subscription_id", payload$.subscription_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/subscriptions/{subscription_id}/charge/preview")(
            pathParams$
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.CreateSubscriptionChargePreviewResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.CreateSubscriptionChargePreviewResponseBody$.inboundSchema.parse({
                ...responseFields$,
                Headers: this.unpackHeaders(response.headers),
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 500, "application/json")) {
            const responseBody = await response.json();
            const result =
                errors.CreateSubscriptionChargePreviewSubscriptionsResponseBody$.inboundSchema.parse(
                    {
                        ...responseFields$,
                        Headers: this.unpackHeaders(response.headers),
                        ...responseBody,
                    }
                );
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get a subscription
     *
     * @remarks
     * Returns a subscription using its ID.
     *
     * Use the `include` parameter to include transaction information in the response.
     */
    async get(
        input: operations.GetSubscriptionRequest,
        options?: RequestOptions
    ): Promise<operations.GetSubscriptionResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.GetSubscriptionRequest$.outboundSchema.parse(input);
        const body$ = null;

        const pathParams$ = {
            subscription_id: enc$.encodeSimple("subscription_id", payload$.subscription_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/subscriptions/{subscription_id}")(pathParams$);

        const query$ = [
            enc$.encodeForm("include", payload$.include, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.GetSubscriptionResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = errors.GetSubscriptionResponseBody$.inboundSchema.parse({
                ...responseFields$,
                Headers: this.unpackHeaders(response.headers),
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = errors.GetSubscriptionSubscriptionsResponseBody$.inboundSchema.parse({
                ...responseFields$,
                Headers: this.unpackHeaders(response.headers),
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 500, "application/json")) {
            const responseBody = await response.json();
            const result =
                errors.GetSubscriptionSubscriptionsResponseResponseBody$.inboundSchema.parse({
                    ...responseFields$,
                    Headers: this.unpackHeaders(response.headers),
                    ...responseBody,
                });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get a transaction to update payment method
     *
     * @remarks
     * Returns a transaction that you can pass to a checkout to let customers update their payment details. Only for subscriptions where `collection_mode` is `automatic`.
     *
     * The transaction returned depends on the status of the related subscription:
     *
     * * Where a subscription is `past_due`, it returns the most recent `past_due` transaction.
     * * Where a subscription is `active`, it creates a new zero amount transaction for the items on a subscription.
     *
     * You can use the returned `checkout.url`, or pass the returned transaction ID to Paddle.js to open a checkout to present customers with a way of updating their payment details.
     */
    async getUpdatedPaymentMethodTransaction(
        input: operations.GetSubscriptionUpdatePaymentMethodTransactionRequest,
        options?: RequestOptions
    ): Promise<operations.GetSubscriptionUpdatePaymentMethodTransactionResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ =
            operations.GetSubscriptionUpdatePaymentMethodTransactionRequest$.outboundSchema.parse(
                input
            );
        const body$ = null;

        const pathParams$ = {
            subscription_id: enc$.encodeSimple("subscription_id", payload$.subscription_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent(
            "/subscriptions/{subscription_id}/update-payment-method-transaction"
        )(pathParams$);

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result =
                operations.GetSubscriptionUpdatePaymentMethodTransactionResponse$.inboundSchema.parse(
                    {
                        ...responseFields$,
                        object: responseBody,
                    }
                );
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result =
                errors.GetSubscriptionUpdatePaymentMethodTransactionResponseBody$.inboundSchema.parse(
                    {
                        ...responseFields$,
                        Headers: this.unpackHeaders(response.headers),
                        ...responseBody,
                    }
                );
            throw result;
        } else if (this.matchResponse(response, 403, "application/json")) {
            const responseBody = await response.json();
            const result =
                errors.GetSubscriptionUpdatePaymentMethodTransactionSubscriptionsResponseBody$.inboundSchema.parse(
                    {
                        ...responseFields$,
                        Headers: this.unpackHeaders(response.headers),
                        ...responseBody,
                    }
                );
            throw result;
        } else if (this.matchResponse(response, 409, "application/json")) {
            const responseBody = await response.json();
            const result =
                errors.GetSubscriptionUpdatePaymentMethodTransactionSubscriptionsResponseResponseBody$.inboundSchema.parse(
                    {
                        ...responseFields$,
                        Headers: this.unpackHeaders(response.headers),
                        ...responseBody,
                    }
                );
            throw result;
        } else if (this.matchResponse(response, 500, "application/json")) {
            const responseBody = await response.json();
            const result =
                errors.GetSubscriptionUpdatePaymentMethodTransactionSubscriptionsResponse500ResponseBody$.inboundSchema.parse(
                    {
                        ...responseFields$,
                        Headers: this.unpackHeaders(response.headers),
                        ...responseBody,
                    }
                );
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * List subscriptions
     *
     * @remarks
     * Returns a paginated list of subscriptions. Use the query parameters to page through results.
     */
    async list(
        input: operations.ListSubscriptionsRequest,
        options?: RequestOptions
    ): Promise<operations.ListSubscriptionsResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.ListSubscriptionsRequest$.outboundSchema.parse(input);
        const body$ = null;

        const path$ = this.templateURLComponent("/subscriptions")();

        const query$ = [
            enc$.encodeForm("after", payload$.after, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("customer_id", payload$.customer_id, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("order_by", payload$.order_by, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("per_page", payload$.per_page, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("price_id", payload$.price_id, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("status", payload$.status, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.ListSubscriptionsResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = errors.ListSubscriptionsResponseBody$.inboundSchema.parse({
                ...responseFields$,
                Headers: this.unpackHeaders(response.headers),
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 500, "application/json")) {
            const responseBody = await response.json();
            const result = errors.ListSubscriptionsSubscriptionsResponseBody$.inboundSchema.parse({
                ...responseFields$,
                Headers: this.unpackHeaders(response.headers),
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Pause a subscription
     *
     * @remarks
     * Pauses a subscription using its ID.
     *
     * To create an open-ended pause, send an empty request body. The subscription remains paused until you send a resume request.
     *
     * To set a resume date, include the `resume_at` field in your request. The subscription remains paused until the resume date, or until you send a resume request.
     *
     * Pauses take place at the end of a subscription billing period. If successful, your response includes a copy of the updated subscription entity with a `schedule_change` to say that the subscription should pause at the end of the billing period. Its `status` remains the same until after the effective date of the scheduled change, at which point it changes to `paused`.
     */
    async pause(
        input: operations.PauseSubscriptionRequest,
        options?: RequestOptions
    ): Promise<operations.PauseSubscriptionResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = operations.PauseSubscriptionRequest$.outboundSchema.parse(input);

        const body$ = enc$.encodeJSON("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            subscription_id: enc$.encodeSimple("subscription_id", payload$.subscription_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/subscriptions/{subscription_id}/pause")(
            pathParams$
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.PauseSubscriptionResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.PauseSubscriptionResponseBody$.inboundSchema.parse({
                ...responseFields$,
                Headers: this.unpackHeaders(response.headers),
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = errors.PauseSubscriptionSubscriptionsResponseBody$.inboundSchema.parse({
                ...responseFields$,
                Headers: this.unpackHeaders(response.headers),
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 409, "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorT$.inboundSchema.parse({
                ...responseFields$,
                Headers: this.unpackHeaders(response.headers),
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 500, "application/json")) {
            const responseBody = await response.json();
            const result =
                errors.PauseSubscriptionSubscriptionsResponseResponseBody$.inboundSchema.parse({
                    ...responseFields$,
                    Headers: this.unpackHeaders(response.headers),
                    ...responseBody,
                });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Preview an update to a subscription
     *
     * @remarks
     * Previews an update for a subscription without applying those changes. Typically used for previewing proration before making changes to a subscription.
     *
     * If successful, your response includes `immediate_transaction`, `next_transaction`, and `recurring_transaction_details` so you can see expected transactions for the changes.
     */
    async previewSubscription(
        input: operations.PreviewSubscriptionRequest,
        options?: RequestOptions
    ): Promise<operations.PreviewSubscriptionResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = operations.PreviewSubscriptionRequest$.outboundSchema.parse(input);

        const body$ = enc$.encodeJSON("body", payload$["subscription-update"], { explode: true });

        const pathParams$ = {
            subscription_id: enc$.encodeSimple("subscription_id", payload$.subscription_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/subscriptions/{subscription_id}/preview")(
            pathParams$
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.PreviewSubscriptionResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Resume a paused subscription
     *
     * @remarks
     * Resumes a paused subscription using its ID. Only `paused` subscriptions can be resumed. You cannot resume a `canceled` subscription.
     *
     * On resume, Paddle bills for a subscription immediately. Subscription billing dates are recalculated based on the resume date.
     *
     * If successful, Paddle returns a copy of the updated subscription entity. The subscription status is `active`, and billing dates are updated to reflect the resume date.
     */
    async resumeSubscription(
        input: operations.ResumeSubscriptionRequest,
        options?: RequestOptions
    ): Promise<operations.ResumeSubscriptionResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = operations.ResumeSubscriptionRequest$.outboundSchema.parse(input);

        const body$ = enc$.encodeJSON("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            subscription_id: enc$.encodeSimple("subscription_id", payload$.subscription_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/subscriptions/{subscription_id}/resume")(
            pathParams$
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.ResumeSubscriptionResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.ResumeSubscriptionResponseBody$.inboundSchema.parse({
                ...responseFields$,
                Headers: this.unpackHeaders(response.headers),
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = errors.ResumeSubscriptionSubscriptionsResponseBody$.inboundSchema.parse({
                ...responseFields$,
                Headers: this.unpackHeaders(response.headers),
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 409, "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorT$.inboundSchema.parse({
                ...responseFields$,
                Headers: this.unpackHeaders(response.headers),
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 500, "application/json")) {
            const responseBody = await response.json();
            const result =
                errors.ResumeSubscriptionSubscriptionsResponseResponseBody$.inboundSchema.parse({
                    ...responseFields$,
                    Headers: this.unpackHeaders(response.headers),
                    ...responseBody,
                });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Update a subscription
     *
     * @remarks
     * Updates a subscription using its ID.
     *
     * When making changes to items on a subscription, you must include the `proration_billing_mode` field to tell Paddle how to bill for those changes. Paddle returns an error if this field is missing when sending `items`.
     *
     * Send the complete list of items that you'd like to be on a subscription — including existing items. If you omit items, they're removed from the subscription.
     *
     * For each item, send `price_id` and `quantity`. Paddle responds with the full price object for each price. If you're updating an existing item, you can omit the `quantity` if you don't want to update it.
     *
     * If successful, your response includes a copy of the updated subscription entity.
     */
    async update(
        input: operations.UpdateSubscriptionRequest,
        options?: RequestOptions
    ): Promise<operations.UpdateSubscriptionResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = operations.UpdateSubscriptionRequest$.outboundSchema.parse(input);

        const body$ = enc$.encodeJSON("body", payload$["subscription-update"], { explode: true });

        const pathParams$ = {
            subscription_id: enc$.encodeSimple("subscription_id", payload$.subscription_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/subscriptions/{subscription_id}")(pathParams$);

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.UpdateSubscriptionResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.UpdateSubscriptionResponseBody$.inboundSchema.parse({
                ...responseFields$,
                Headers: this.unpackHeaders(response.headers),
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = errors.UpdateSubscriptionSubscriptionsResponseBody$.inboundSchema.parse({
                ...responseFields$,
                Headers: this.unpackHeaders(response.headers),
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 409, "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorT$.inboundSchema.parse({
                ...responseFields$,
                Headers: this.unpackHeaders(response.headers),
                ...responseBody,
            });
            throw result;
        } else if (this.matchResponse(response, 500, "application/json")) {
            const responseBody = await response.json();
            const result =
                errors.UpdateSubscriptionSubscriptionsResponseResponseBody$.inboundSchema.parse({
                    ...responseFields$,
                    Headers: this.unpackHeaders(response.headers),
                    ...responseBody,
                });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }
}
